// Generated by the capnpc-rust plugin to the Cap'n Proto schema compiler.
// DO NOT EDIT.
// source: service.capnp


pub mod file_state {
  #[derive(Copy, Clone)]
  pub struct Owned;
  impl <'a> ::capnp::traits::Owned<'a> for Owned { type Reader = Reader<'a>; type Builder = Builder<'a>; }
  impl <'a> ::capnp::traits::OwnedStruct<'a> for Owned { type Reader = Reader<'a>; type Builder = Builder<'a>; }
  impl ::capnp::traits::Pipelined for Owned { type Pipeline = Pipeline; }

  #[derive(Clone, Copy)]
  pub struct Reader<'a> { reader: ::capnp::private::layout::StructReader<'a> }

  impl <'a,> ::capnp::traits::HasTypeId for Reader<'a,>  {
    #[inline]
    fn type_id() -> u64 { _private::TYPE_ID }
  }
  impl <'a,> ::capnp::traits::FromStructReader<'a> for Reader<'a,>  {
    fn new(reader: ::capnp::private::layout::StructReader<'a>) -> Reader<'a,> {
      Reader { reader: reader,  }
    }
  }

  impl <'a,> ::capnp::traits::FromPointerReader<'a> for Reader<'a,>  {
    fn get_from_pointer(reader: &::capnp::private::layout::PointerReader<'a>) -> ::capnp::Result<Reader<'a,>> {
      ::std::result::Result::Ok(::capnp::traits::FromStructReader::new(try!(reader.get_struct(::std::ptr::null()))))
    }
  }

  impl <'a,> ::capnp::traits::Imbue<'a> for Reader<'a,>  {
    fn imbue(&mut self, cap_table: &'a ::capnp::private::layout::CapTable) {
      self.reader.imbue(::capnp::private::layout::CapTableReader::Plain(cap_table))
    }
  }

  impl <'a,> Reader<'a,>  {
    pub fn reborrow<'b>(&'b self) -> Reader<'b,> {
      Reader { .. *self }
    }

    pub fn total_size(&self) -> ::capnp::Result<::capnp::MessageSize> {
      self.reader.total_size()
    }
    #[inline]
    pub fn get_path(self) -> ::capnp::Result<::capnp::text::Reader<'a>> {
      self.reader.get_pointer_field(0).get_text(::std::ptr::null(), 0)
    }
    pub fn has_path(&self) -> bool {
      !self.reader.get_pointer_field(0).is_null()
    }
    #[inline]
    pub fn get_state(self) -> ::std::result::Result<::data_capnp::FileState,::capnp::NotInSchema> {
      ::capnp::traits::FromU16::from_u16(self.reader.get_data_field::<u16>(0))
    }
  }

  pub struct Builder<'a> { builder: ::capnp::private::layout::StructBuilder<'a> }
  impl <'a,> ::capnp::traits::HasStructSize for Builder<'a,>  {
    #[inline]
    fn struct_size() -> ::capnp::private::layout::StructSize { _private::STRUCT_SIZE }
  }
  impl <'a,> ::capnp::traits::HasTypeId for Builder<'a,>  {
    #[inline]
    fn type_id() -> u64 { _private::TYPE_ID }
  }
  impl <'a,> ::capnp::traits::FromStructBuilder<'a> for Builder<'a,>  {
    fn new(builder: ::capnp::private::layout::StructBuilder<'a>) -> Builder<'a, > {
      Builder { builder: builder,  }
    }
  }

  impl <'a,> ::capnp::traits::ImbueMut<'a> for Builder<'a,>  {
    fn imbue_mut(&mut self, cap_table: &'a mut ::capnp::private::layout::CapTable) {
      self.builder.imbue(::capnp::private::layout::CapTableBuilder::Plain(cap_table))
    }
  }

  impl <'a,> ::capnp::traits::FromPointerBuilder<'a> for Builder<'a,>  {
    fn init_pointer(builder: ::capnp::private::layout::PointerBuilder<'a>, _size: u32) -> Builder<'a,> {
      ::capnp::traits::FromStructBuilder::new(builder.init_struct(_private::STRUCT_SIZE))
    }
    fn get_from_pointer(builder: ::capnp::private::layout::PointerBuilder<'a>) -> ::capnp::Result<Builder<'a,>> {
      ::std::result::Result::Ok(::capnp::traits::FromStructBuilder::new(try!(builder.get_struct(_private::STRUCT_SIZE, ::std::ptr::null()))))
    }
  }

  impl <'a,> ::capnp::traits::SetPointerBuilder<Builder<'a,>> for Reader<'a,>  {
    fn set_pointer_builder<'b>(pointer: ::capnp::private::layout::PointerBuilder<'b>, value: Reader<'a,>, canonicalize: bool) -> ::capnp::Result<()> { pointer.set_struct(&value.reader, canonicalize) }
  }

  impl <'a,> Builder<'a,>  {
    pub fn as_reader(self) -> Reader<'a,> {
      ::capnp::traits::FromStructReader::new(self.builder.as_reader())
    }
    pub fn reborrow<'b>(&'b mut self) -> Builder<'b,> {
      Builder { .. *self }
    }
    pub fn reborrow_as_reader<'b>(&'b self) -> Reader<'b,> {
      ::capnp::traits::FromStructReader::new(self.builder.as_reader())
    }

    pub fn total_size(&self) -> ::capnp::Result<::capnp::MessageSize> {
      self.builder.as_reader().total_size()
    }
    #[inline]
    pub fn get_path(self) -> ::capnp::Result<::capnp::text::Builder<'a>> {
      self.builder.get_pointer_field(0).get_text(::std::ptr::null(), 0)
    }
    #[inline]
    pub fn set_path(&mut self, value: ::capnp::text::Reader)  {
      self.builder.get_pointer_field(0).set_text(value);
    }
    #[inline]
    pub fn init_path(self, size: u32) -> ::capnp::text::Builder<'a> {
      self.builder.get_pointer_field(0).init_text(size)
    }
    pub fn has_path(&self) -> bool {
      !self.builder.get_pointer_field(0).is_null()
    }
    #[inline]
    pub fn get_state(self) -> ::std::result::Result<::data_capnp::FileState,::capnp::NotInSchema> {
      ::capnp::traits::FromU16::from_u16(self.builder.get_data_field::<u16>(0))
    }
    #[inline]
    pub fn set_state(&mut self, value: ::data_capnp::FileState)  {
      self.builder.set_data_field::<u16>(0, value as u16)
    }
  }

  pub struct Pipeline { _typeless: ::capnp::any_pointer::Pipeline }
  impl ::capnp::capability::FromTypelessPipeline for Pipeline {
    fn new(typeless: ::capnp::any_pointer::Pipeline) -> Pipeline {
      Pipeline { _typeless: typeless,  }
    }
  }
  impl Pipeline  {
  }
  mod _private {
    use capnp::private::layout;
    pub const STRUCT_SIZE: layout::StructSize = layout::StructSize { data: 1, pointers: 1 };
    pub const TYPE_ID: u64 = 0xc3c5e55502df8a71;
  }
}


pub mod file_tracker {
  #![allow(unused_variables)]
  pub type RegisterListenerParams<> = ::capnp::capability::Params<::service_capnp::file_tracker::register_listener_params::Owned>;
  pub type RegisterListenerResults<> = ::capnp::capability::Results<::service_capnp::file_tracker::register_listener_results::Owned>;
  pub type GetSnapshotParams<> = ::capnp::capability::Params<::service_capnp::file_tracker::get_snapshot_params::Owned>;
  pub type GetSnapshotResults<> = ::capnp::capability::Results<::service_capnp::file_tracker::get_snapshot_results::Owned>;

  pub struct Client {
    pub client: ::capnp::capability::Client,
  }
  impl  ::capnp::capability::FromClientHook for Client {
    fn new(hook: Box<::capnp::private::capability::ClientHook>) -> Client {
      Client { client: ::capnp::capability::Client::new(hook),  }
    }
  }
  #[derive(Copy, Clone)]
  pub struct Owned;
  impl <'a> ::capnp::traits::Owned<'a> for Owned { type Reader = Client; type Builder = Client; }
  impl ::capnp::traits::Pipelined for Owned { type Pipeline = Client; }
  impl <'a,> ::capnp::traits::FromPointerReader<'a> for Client<>  {
    fn get_from_pointer(reader: &::capnp::private::layout::PointerReader<'a>) -> ::capnp::Result<Client<>> {
      ::std::result::Result::Ok(::capnp::capability::FromClientHook::new(try!(reader.get_capability())))
    }
  }
  impl <'a,> ::capnp::traits::FromPointerBuilder<'a> for Client<>  {
    fn init_pointer(_builder: ::capnp::private::layout::PointerBuilder<'a>, _size: u32) -> Client<> {
      unimplemented!()
    }
    fn get_from_pointer(builder: ::capnp::private::layout::PointerBuilder<'a>) -> ::capnp::Result<Client<>> {
      ::std::result::Result::Ok(::capnp::capability::FromClientHook::new(try!(builder.get_capability())))
    }
  }

  impl <> ::capnp::traits::SetPointerBuilder<Client<>> for Client<>  {
    fn set_pointer_builder<'a>(pointer: ::capnp::private::layout::PointerBuilder<'a>, from: Client<>, _canonicalize: bool) -> ::capnp::Result<()> {
      ::std::result::Result::Ok(pointer.set_capability(from.client.hook))
    }
  }
  pub struct ToClient<U>{pub u: U}
  impl <U: Server + 'static> ToClient<U> {
  pub fn new(u: U) -> ToClient<U> { ToClient {u: u} }
    pub fn from_server<_T: ::capnp::private::capability::ServerHook>(self) -> Client {
      Client { client: _T::new_client(::std::boxed::Box::new(ServerDispatch { server: ::std::boxed::Box::new(self.u),  })),  }
    }
  }
  impl  ::capnp::traits::HasTypeId for Client {
    #[inline]
    fn type_id() -> u64 { _private::TYPE_ID }
  }
  impl  Clone for Client {
    fn clone(&self) -> Client {
      Client { client: ::capnp::capability::Client::new(self.client.hook.add_ref()),  }
    }
  }
  impl  Client {
    pub fn register_listener_request(&self) -> ::capnp::capability::Request<::service_capnp::file_tracker::register_listener_params::Owned,::service_capnp::file_tracker::register_listener_results::Owned> {
      self.client.new_call(_private::TYPE_ID, 0, None)
    }
    pub fn get_snapshot_request(&self) -> ::capnp::capability::Request<::service_capnp::file_tracker::get_snapshot_params::Owned,::service_capnp::file_tracker::get_snapshot_results::Owned> {
      self.client.new_call(_private::TYPE_ID, 1, None)
    }
  }
  pub trait Server<>  {
    fn register_listener(&mut self, _: RegisterListenerParams<>, _: RegisterListenerResults<>) -> ::capnp::capability::Promise<(), ::capnp::Error> { ::capnp::capability::Promise::err(::capnp::Error::unimplemented("method not implemented".to_string())) }
    fn get_snapshot(&mut self, _: GetSnapshotParams<>, _: GetSnapshotResults<>) -> ::capnp::capability::Promise<(), ::capnp::Error> { ::capnp::capability::Promise::err(::capnp::Error::unimplemented("method not implemented".to_string())) }
  }
  pub struct ServerDispatch<_T,> {
    pub server: Box<_T>,
  }
  impl <_T: Server> ::capnp::capability::Server for ServerDispatch<_T> {
    fn dispatch_call(&mut self, interface_id: u64, method_id: u16, params: ::capnp::capability::Params<::capnp::any_pointer::Owned>, results: ::capnp::capability::Results<::capnp::any_pointer::Owned>) -> ::capnp::capability::Promise<(), ::capnp::Error> {
      match interface_id {
        _private::TYPE_ID => ServerDispatch::<_T, >::dispatch_call_internal(&mut *self.server, method_id, params, results),
        _ => { ::capnp::capability::Promise::err(::capnp::Error::unimplemented("Method not implemented.".to_string())) }
      }
    }
  }
  impl <_T :Server> ServerDispatch<_T> {
    pub fn dispatch_call_internal(server: &mut _T, method_id: u16, params: ::capnp::capability::Params<::capnp::any_pointer::Owned>, results: ::capnp::capability::Results<::capnp::any_pointer::Owned>) -> ::capnp::capability::Promise<(), ::capnp::Error> {
      match method_id {
        0 => server.register_listener(::capnp::private::capability::internal_get_typed_params(params), ::capnp::private::capability::internal_get_typed_results(results)),
        1 => server.get_snapshot(::capnp::private::capability::internal_get_typed_params(params), ::capnp::private::capability::internal_get_typed_results(results)),
        _ => { ::capnp::capability::Promise::err(::capnp::Error::unimplemented("Method not implemented.".to_string())) }
      }
    }
  }
  pub mod _private {
    pub const TYPE_ID: u64 = 0xf4f886783a4d2afe;
  }


  pub mod snapshot {
    #![allow(unused_variables)]
    pub type GetAllFilesParams<> = ::capnp::capability::Params<::service_capnp::file_tracker::snapshot::get_all_files_params::Owned>;
    pub type GetAllFilesResults<> = ::capnp::capability::Results<::service_capnp::file_tracker::snapshot::get_all_files_results::Owned>;
    pub type GetTypeParams<> = ::capnp::capability::Params<::service_capnp::file_tracker::snapshot::get_type_params::Owned>;
    pub type GetTypeResults<> = ::capnp::capability::Results<::service_capnp::file_tracker::snapshot::get_type_results::Owned>;

    pub struct Client {
      pub client: ::capnp::capability::Client,
    }
    impl  ::capnp::capability::FromClientHook for Client {
      fn new(hook: Box<::capnp::private::capability::ClientHook>) -> Client {
        Client { client: ::capnp::capability::Client::new(hook),  }
      }
    }
    #[derive(Copy, Clone)]
    pub struct Owned;
    impl <'a> ::capnp::traits::Owned<'a> for Owned { type Reader = Client; type Builder = Client; }
    impl ::capnp::traits::Pipelined for Owned { type Pipeline = Client; }
    impl <'a,> ::capnp::traits::FromPointerReader<'a> for Client<>  {
      fn get_from_pointer(reader: &::capnp::private::layout::PointerReader<'a>) -> ::capnp::Result<Client<>> {
        ::std::result::Result::Ok(::capnp::capability::FromClientHook::new(try!(reader.get_capability())))
      }
    }
    impl <'a,> ::capnp::traits::FromPointerBuilder<'a> for Client<>  {
      fn init_pointer(_builder: ::capnp::private::layout::PointerBuilder<'a>, _size: u32) -> Client<> {
        unimplemented!()
      }
      fn get_from_pointer(builder: ::capnp::private::layout::PointerBuilder<'a>) -> ::capnp::Result<Client<>> {
        ::std::result::Result::Ok(::capnp::capability::FromClientHook::new(try!(builder.get_capability())))
      }
    }

    impl <> ::capnp::traits::SetPointerBuilder<Client<>> for Client<>  {
      fn set_pointer_builder<'a>(pointer: ::capnp::private::layout::PointerBuilder<'a>, from: Client<>, _canonicalize: bool) -> ::capnp::Result<()> {
        ::std::result::Result::Ok(pointer.set_capability(from.client.hook))
      }
    }
    pub struct ToClient<U>{pub u: U}
    impl <U: Server + 'static> ToClient<U> {
    pub fn new(u: U) -> ToClient<U> { ToClient {u: u} }
      pub fn from_server<_T: ::capnp::private::capability::ServerHook>(self) -> Client {
        Client { client: _T::new_client(::std::boxed::Box::new(ServerDispatch { server: ::std::boxed::Box::new(self.u),  })),  }
      }
    }
    impl  ::capnp::traits::HasTypeId for Client {
      #[inline]
      fn type_id() -> u64 { _private::TYPE_ID }
    }
    impl  Clone for Client {
      fn clone(&self) -> Client {
        Client { client: ::capnp::capability::Client::new(self.client.hook.add_ref()),  }
      }
    }
    impl  Client {
      pub fn get_all_files_request(&self) -> ::capnp::capability::Request<::service_capnp::file_tracker::snapshot::get_all_files_params::Owned,::service_capnp::file_tracker::snapshot::get_all_files_results::Owned> {
        self.client.new_call(_private::TYPE_ID, 0, None)
      }
      pub fn get_type_request(&self) -> ::capnp::capability::Request<::service_capnp::file_tracker::snapshot::get_type_params::Owned,::service_capnp::file_tracker::snapshot::get_type_results::Owned> {
        self.client.new_call(_private::TYPE_ID, 1, None)
      }
    }
    pub trait Server<>  {
      fn get_all_files(&mut self, _: GetAllFilesParams<>, _: GetAllFilesResults<>) -> ::capnp::capability::Promise<(), ::capnp::Error> { ::capnp::capability::Promise::err(::capnp::Error::unimplemented("method not implemented".to_string())) }
      fn get_type(&mut self, _: GetTypeParams<>, _: GetTypeResults<>) -> ::capnp::capability::Promise<(), ::capnp::Error> { ::capnp::capability::Promise::err(::capnp::Error::unimplemented("method not implemented".to_string())) }
    }
    pub struct ServerDispatch<_T,> {
      pub server: Box<_T>,
    }
    impl <_T: Server> ::capnp::capability::Server for ServerDispatch<_T> {
      fn dispatch_call(&mut self, interface_id: u64, method_id: u16, params: ::capnp::capability::Params<::capnp::any_pointer::Owned>, results: ::capnp::capability::Results<::capnp::any_pointer::Owned>) -> ::capnp::capability::Promise<(), ::capnp::Error> {
        match interface_id {
          _private::TYPE_ID => ServerDispatch::<_T, >::dispatch_call_internal(&mut *self.server, method_id, params, results),
          _ => { ::capnp::capability::Promise::err(::capnp::Error::unimplemented("Method not implemented.".to_string())) }
        }
      }
    }
    impl <_T :Server> ServerDispatch<_T> {
      pub fn dispatch_call_internal(server: &mut _T, method_id: u16, params: ::capnp::capability::Params<::capnp::any_pointer::Owned>, results: ::capnp::capability::Results<::capnp::any_pointer::Owned>) -> ::capnp::capability::Promise<(), ::capnp::Error> {
        match method_id {
          0 => server.get_all_files(::capnp::private::capability::internal_get_typed_params(params), ::capnp::private::capability::internal_get_typed_results(results)),
          1 => server.get_type(::capnp::private::capability::internal_get_typed_params(params), ::capnp::private::capability::internal_get_typed_results(results)),
          _ => { ::capnp::capability::Promise::err(::capnp::Error::unimplemented("Method not implemented.".to_string())) }
        }
      }
    }
    pub mod _private {
      pub const TYPE_ID: u64 = 0xbab97299fc5db7c6;
    }

    pub mod get_all_files_params {
      #[derive(Copy, Clone)]
      pub struct Owned;
      impl <'a> ::capnp::traits::Owned<'a> for Owned { type Reader = Reader<'a>; type Builder = Builder<'a>; }
      impl <'a> ::capnp::traits::OwnedStruct<'a> for Owned { type Reader = Reader<'a>; type Builder = Builder<'a>; }
      impl ::capnp::traits::Pipelined for Owned { type Pipeline = Pipeline; }

      #[derive(Clone, Copy)]
      pub struct Reader<'a> { reader: ::capnp::private::layout::StructReader<'a> }

      impl <'a,> ::capnp::traits::HasTypeId for Reader<'a,>  {
        #[inline]
        fn type_id() -> u64 { _private::TYPE_ID }
      }
      impl <'a,> ::capnp::traits::FromStructReader<'a> for Reader<'a,>  {
        fn new(reader: ::capnp::private::layout::StructReader<'a>) -> Reader<'a,> {
          Reader { reader: reader,  }
        }
      }

      impl <'a,> ::capnp::traits::FromPointerReader<'a> for Reader<'a,>  {
        fn get_from_pointer(reader: &::capnp::private::layout::PointerReader<'a>) -> ::capnp::Result<Reader<'a,>> {
          ::std::result::Result::Ok(::capnp::traits::FromStructReader::new(try!(reader.get_struct(::std::ptr::null()))))
        }
      }

      impl <'a,> ::capnp::traits::Imbue<'a> for Reader<'a,>  {
        fn imbue(&mut self, cap_table: &'a ::capnp::private::layout::CapTable) {
          self.reader.imbue(::capnp::private::layout::CapTableReader::Plain(cap_table))
        }
      }

      impl <'a,> Reader<'a,>  {
        pub fn reborrow<'b>(&'b self) -> Reader<'b,> {
          Reader { .. *self }
        }

        pub fn total_size(&self) -> ::capnp::Result<::capnp::MessageSize> {
          self.reader.total_size()
        }
      }

      pub struct Builder<'a> { builder: ::capnp::private::layout::StructBuilder<'a> }
      impl <'a,> ::capnp::traits::HasStructSize for Builder<'a,>  {
        #[inline]
        fn struct_size() -> ::capnp::private::layout::StructSize { _private::STRUCT_SIZE }
      }
      impl <'a,> ::capnp::traits::HasTypeId for Builder<'a,>  {
        #[inline]
        fn type_id() -> u64 { _private::TYPE_ID }
      }
      impl <'a,> ::capnp::traits::FromStructBuilder<'a> for Builder<'a,>  {
        fn new(builder: ::capnp::private::layout::StructBuilder<'a>) -> Builder<'a, > {
          Builder { builder: builder,  }
        }
      }

      impl <'a,> ::capnp::traits::ImbueMut<'a> for Builder<'a,>  {
        fn imbue_mut(&mut self, cap_table: &'a mut ::capnp::private::layout::CapTable) {
          self.builder.imbue(::capnp::private::layout::CapTableBuilder::Plain(cap_table))
        }
      }

      impl <'a,> ::capnp::traits::FromPointerBuilder<'a> for Builder<'a,>  {
        fn init_pointer(builder: ::capnp::private::layout::PointerBuilder<'a>, _size: u32) -> Builder<'a,> {
          ::capnp::traits::FromStructBuilder::new(builder.init_struct(_private::STRUCT_SIZE))
        }
        fn get_from_pointer(builder: ::capnp::private::layout::PointerBuilder<'a>) -> ::capnp::Result<Builder<'a,>> {
          ::std::result::Result::Ok(::capnp::traits::FromStructBuilder::new(try!(builder.get_struct(_private::STRUCT_SIZE, ::std::ptr::null()))))
        }
      }

      impl <'a,> ::capnp::traits::SetPointerBuilder<Builder<'a,>> for Reader<'a,>  {
        fn set_pointer_builder<'b>(pointer: ::capnp::private::layout::PointerBuilder<'b>, value: Reader<'a,>, canonicalize: bool) -> ::capnp::Result<()> { pointer.set_struct(&value.reader, canonicalize) }
      }

      impl <'a,> Builder<'a,>  {
        pub fn as_reader(self) -> Reader<'a,> {
          ::capnp::traits::FromStructReader::new(self.builder.as_reader())
        }
        pub fn reborrow<'b>(&'b mut self) -> Builder<'b,> {
          Builder { .. *self }
        }
        pub fn reborrow_as_reader<'b>(&'b self) -> Reader<'b,> {
          ::capnp::traits::FromStructReader::new(self.builder.as_reader())
        }

        pub fn total_size(&self) -> ::capnp::Result<::capnp::MessageSize> {
          self.builder.as_reader().total_size()
        }
      }

      pub struct Pipeline { _typeless: ::capnp::any_pointer::Pipeline }
      impl ::capnp::capability::FromTypelessPipeline for Pipeline {
        fn new(typeless: ::capnp::any_pointer::Pipeline) -> Pipeline {
          Pipeline { _typeless: typeless,  }
        }
      }
      impl Pipeline  {
      }
      mod _private {
        use capnp::private::layout;
        pub const STRUCT_SIZE: layout::StructSize = layout::StructSize { data: 0, pointers: 0 };
        pub const TYPE_ID: u64 = 0xd9eaae3cf231c8ce;
      }
    }

    pub mod get_all_files_results {
      #[derive(Copy, Clone)]
      pub struct Owned;
      impl <'a> ::capnp::traits::Owned<'a> for Owned { type Reader = Reader<'a>; type Builder = Builder<'a>; }
      impl <'a> ::capnp::traits::OwnedStruct<'a> for Owned { type Reader = Reader<'a>; type Builder = Builder<'a>; }
      impl ::capnp::traits::Pipelined for Owned { type Pipeline = Pipeline; }

      #[derive(Clone, Copy)]
      pub struct Reader<'a> { reader: ::capnp::private::layout::StructReader<'a> }

      impl <'a,> ::capnp::traits::HasTypeId for Reader<'a,>  {
        #[inline]
        fn type_id() -> u64 { _private::TYPE_ID }
      }
      impl <'a,> ::capnp::traits::FromStructReader<'a> for Reader<'a,>  {
        fn new(reader: ::capnp::private::layout::StructReader<'a>) -> Reader<'a,> {
          Reader { reader: reader,  }
        }
      }

      impl <'a,> ::capnp::traits::FromPointerReader<'a> for Reader<'a,>  {
        fn get_from_pointer(reader: &::capnp::private::layout::PointerReader<'a>) -> ::capnp::Result<Reader<'a,>> {
          ::std::result::Result::Ok(::capnp::traits::FromStructReader::new(try!(reader.get_struct(::std::ptr::null()))))
        }
      }

      impl <'a,> ::capnp::traits::Imbue<'a> for Reader<'a,>  {
        fn imbue(&mut self, cap_table: &'a ::capnp::private::layout::CapTable) {
          self.reader.imbue(::capnp::private::layout::CapTableReader::Plain(cap_table))
        }
      }

      impl <'a,> Reader<'a,>  {
        pub fn reborrow<'b>(&'b self) -> Reader<'b,> {
          Reader { .. *self }
        }

        pub fn total_size(&self) -> ::capnp::Result<::capnp::MessageSize> {
          self.reader.total_size()
        }
        #[inline]
        pub fn get_files(self) -> ::capnp::Result<::capnp::struct_list::Reader<'a,::service_capnp::file_state::Owned>> {
          ::capnp::traits::FromPointerReader::get_from_pointer(&self.reader.get_pointer_field(0))
        }
        pub fn has_files(&self) -> bool {
          !self.reader.get_pointer_field(0).is_null()
        }
      }

      pub struct Builder<'a> { builder: ::capnp::private::layout::StructBuilder<'a> }
      impl <'a,> ::capnp::traits::HasStructSize for Builder<'a,>  {
        #[inline]
        fn struct_size() -> ::capnp::private::layout::StructSize { _private::STRUCT_SIZE }
      }
      impl <'a,> ::capnp::traits::HasTypeId for Builder<'a,>  {
        #[inline]
        fn type_id() -> u64 { _private::TYPE_ID }
      }
      impl <'a,> ::capnp::traits::FromStructBuilder<'a> for Builder<'a,>  {
        fn new(builder: ::capnp::private::layout::StructBuilder<'a>) -> Builder<'a, > {
          Builder { builder: builder,  }
        }
      }

      impl <'a,> ::capnp::traits::ImbueMut<'a> for Builder<'a,>  {
        fn imbue_mut(&mut self, cap_table: &'a mut ::capnp::private::layout::CapTable) {
          self.builder.imbue(::capnp::private::layout::CapTableBuilder::Plain(cap_table))
        }
      }

      impl <'a,> ::capnp::traits::FromPointerBuilder<'a> for Builder<'a,>  {
        fn init_pointer(builder: ::capnp::private::layout::PointerBuilder<'a>, _size: u32) -> Builder<'a,> {
          ::capnp::traits::FromStructBuilder::new(builder.init_struct(_private::STRUCT_SIZE))
        }
        fn get_from_pointer(builder: ::capnp::private::layout::PointerBuilder<'a>) -> ::capnp::Result<Builder<'a,>> {
          ::std::result::Result::Ok(::capnp::traits::FromStructBuilder::new(try!(builder.get_struct(_private::STRUCT_SIZE, ::std::ptr::null()))))
        }
      }

      impl <'a,> ::capnp::traits::SetPointerBuilder<Builder<'a,>> for Reader<'a,>  {
        fn set_pointer_builder<'b>(pointer: ::capnp::private::layout::PointerBuilder<'b>, value: Reader<'a,>, canonicalize: bool) -> ::capnp::Result<()> { pointer.set_struct(&value.reader, canonicalize) }
      }

      impl <'a,> Builder<'a,>  {
        pub fn as_reader(self) -> Reader<'a,> {
          ::capnp::traits::FromStructReader::new(self.builder.as_reader())
        }
        pub fn reborrow<'b>(&'b mut self) -> Builder<'b,> {
          Builder { .. *self }
        }
        pub fn reborrow_as_reader<'b>(&'b self) -> Reader<'b,> {
          ::capnp::traits::FromStructReader::new(self.builder.as_reader())
        }

        pub fn total_size(&self) -> ::capnp::Result<::capnp::MessageSize> {
          self.builder.as_reader().total_size()
        }
        #[inline]
        pub fn get_files(self) -> ::capnp::Result<::capnp::struct_list::Builder<'a,::service_capnp::file_state::Owned>> {
          ::capnp::traits::FromPointerBuilder::get_from_pointer(self.builder.get_pointer_field(0))
        }
        #[inline]
        pub fn set_files(&mut self, value: ::capnp::struct_list::Reader<'a,::service_capnp::file_state::Owned>) -> ::capnp::Result<()> {
          ::capnp::traits::SetPointerBuilder::set_pointer_builder(self.builder.get_pointer_field(0), value, false)
        }
        #[inline]
        pub fn init_files(self, size: u32) -> ::capnp::struct_list::Builder<'a,::service_capnp::file_state::Owned> {
          ::capnp::traits::FromPointerBuilder::init_pointer(self.builder.get_pointer_field(0), size)
        }
        pub fn has_files(&self) -> bool {
          !self.builder.get_pointer_field(0).is_null()
        }
      }

      pub struct Pipeline { _typeless: ::capnp::any_pointer::Pipeline }
      impl ::capnp::capability::FromTypelessPipeline for Pipeline {
        fn new(typeless: ::capnp::any_pointer::Pipeline) -> Pipeline {
          Pipeline { _typeless: typeless,  }
        }
      }
      impl Pipeline  {
      }
      mod _private {
        use capnp::private::layout;
        pub const STRUCT_SIZE: layout::StructSize = layout::StructSize { data: 0, pointers: 1 };
        pub const TYPE_ID: u64 = 0xa51ce3cd32d294d3;
      }
    }

    pub mod get_type_params {
      #[derive(Copy, Clone)]
      pub struct Owned;
      impl <'a> ::capnp::traits::Owned<'a> for Owned { type Reader = Reader<'a>; type Builder = Builder<'a>; }
      impl <'a> ::capnp::traits::OwnedStruct<'a> for Owned { type Reader = Reader<'a>; type Builder = Builder<'a>; }
      impl ::capnp::traits::Pipelined for Owned { type Pipeline = Pipeline; }

      #[derive(Clone, Copy)]
      pub struct Reader<'a> { reader: ::capnp::private::layout::StructReader<'a> }

      impl <'a,> ::capnp::traits::HasTypeId for Reader<'a,>  {
        #[inline]
        fn type_id() -> u64 { _private::TYPE_ID }
      }
      impl <'a,> ::capnp::traits::FromStructReader<'a> for Reader<'a,>  {
        fn new(reader: ::capnp::private::layout::StructReader<'a>) -> Reader<'a,> {
          Reader { reader: reader,  }
        }
      }

      impl <'a,> ::capnp::traits::FromPointerReader<'a> for Reader<'a,>  {
        fn get_from_pointer(reader: &::capnp::private::layout::PointerReader<'a>) -> ::capnp::Result<Reader<'a,>> {
          ::std::result::Result::Ok(::capnp::traits::FromStructReader::new(try!(reader.get_struct(::std::ptr::null()))))
        }
      }

      impl <'a,> ::capnp::traits::Imbue<'a> for Reader<'a,>  {
        fn imbue(&mut self, cap_table: &'a ::capnp::private::layout::CapTable) {
          self.reader.imbue(::capnp::private::layout::CapTableReader::Plain(cap_table))
        }
      }

      impl <'a,> Reader<'a,>  {
        pub fn reborrow<'b>(&'b self) -> Reader<'b,> {
          Reader { .. *self }
        }

        pub fn total_size(&self) -> ::capnp::Result<::capnp::MessageSize> {
          self.reader.total_size()
        }
        #[inline]
        pub fn get_path(self) -> ::capnp::Result<::capnp::text::Reader<'a>> {
          self.reader.get_pointer_field(0).get_text(::std::ptr::null(), 0)
        }
        pub fn has_path(&self) -> bool {
          !self.reader.get_pointer_field(0).is_null()
        }
      }

      pub struct Builder<'a> { builder: ::capnp::private::layout::StructBuilder<'a> }
      impl <'a,> ::capnp::traits::HasStructSize for Builder<'a,>  {
        #[inline]
        fn struct_size() -> ::capnp::private::layout::StructSize { _private::STRUCT_SIZE }
      }
      impl <'a,> ::capnp::traits::HasTypeId for Builder<'a,>  {
        #[inline]
        fn type_id() -> u64 { _private::TYPE_ID }
      }
      impl <'a,> ::capnp::traits::FromStructBuilder<'a> for Builder<'a,>  {
        fn new(builder: ::capnp::private::layout::StructBuilder<'a>) -> Builder<'a, > {
          Builder { builder: builder,  }
        }
      }

      impl <'a,> ::capnp::traits::ImbueMut<'a> for Builder<'a,>  {
        fn imbue_mut(&mut self, cap_table: &'a mut ::capnp::private::layout::CapTable) {
          self.builder.imbue(::capnp::private::layout::CapTableBuilder::Plain(cap_table))
        }
      }

      impl <'a,> ::capnp::traits::FromPointerBuilder<'a> for Builder<'a,>  {
        fn init_pointer(builder: ::capnp::private::layout::PointerBuilder<'a>, _size: u32) -> Builder<'a,> {
          ::capnp::traits::FromStructBuilder::new(builder.init_struct(_private::STRUCT_SIZE))
        }
        fn get_from_pointer(builder: ::capnp::private::layout::PointerBuilder<'a>) -> ::capnp::Result<Builder<'a,>> {
          ::std::result::Result::Ok(::capnp::traits::FromStructBuilder::new(try!(builder.get_struct(_private::STRUCT_SIZE, ::std::ptr::null()))))
        }
      }

      impl <'a,> ::capnp::traits::SetPointerBuilder<Builder<'a,>> for Reader<'a,>  {
        fn set_pointer_builder<'b>(pointer: ::capnp::private::layout::PointerBuilder<'b>, value: Reader<'a,>, canonicalize: bool) -> ::capnp::Result<()> { pointer.set_struct(&value.reader, canonicalize) }
      }

      impl <'a,> Builder<'a,>  {
        pub fn as_reader(self) -> Reader<'a,> {
          ::capnp::traits::FromStructReader::new(self.builder.as_reader())
        }
        pub fn reborrow<'b>(&'b mut self) -> Builder<'b,> {
          Builder { .. *self }
        }
        pub fn reborrow_as_reader<'b>(&'b self) -> Reader<'b,> {
          ::capnp::traits::FromStructReader::new(self.builder.as_reader())
        }

        pub fn total_size(&self) -> ::capnp::Result<::capnp::MessageSize> {
          self.builder.as_reader().total_size()
        }
        #[inline]
        pub fn get_path(self) -> ::capnp::Result<::capnp::text::Builder<'a>> {
          self.builder.get_pointer_field(0).get_text(::std::ptr::null(), 0)
        }
        #[inline]
        pub fn set_path(&mut self, value: ::capnp::text::Reader)  {
          self.builder.get_pointer_field(0).set_text(value);
        }
        #[inline]
        pub fn init_path(self, size: u32) -> ::capnp::text::Builder<'a> {
          self.builder.get_pointer_field(0).init_text(size)
        }
        pub fn has_path(&self) -> bool {
          !self.builder.get_pointer_field(0).is_null()
        }
      }

      pub struct Pipeline { _typeless: ::capnp::any_pointer::Pipeline }
      impl ::capnp::capability::FromTypelessPipeline for Pipeline {
        fn new(typeless: ::capnp::any_pointer::Pipeline) -> Pipeline {
          Pipeline { _typeless: typeless,  }
        }
      }
      impl Pipeline  {
      }
      mod _private {
        use capnp::private::layout;
        pub const STRUCT_SIZE: layout::StructSize = layout::StructSize { data: 0, pointers: 1 };
        pub const TYPE_ID: u64 = 0xec2ef481a250946e;
      }
    }

    pub mod get_type_results {
      #[derive(Copy, Clone)]
      pub struct Owned;
      impl <'a> ::capnp::traits::Owned<'a> for Owned { type Reader = Reader<'a>; type Builder = Builder<'a>; }
      impl <'a> ::capnp::traits::OwnedStruct<'a> for Owned { type Reader = Reader<'a>; type Builder = Builder<'a>; }
      impl ::capnp::traits::Pipelined for Owned { type Pipeline = Pipeline; }

      #[derive(Clone, Copy)]
      pub struct Reader<'a> { reader: ::capnp::private::layout::StructReader<'a> }

      impl <'a,> ::capnp::traits::HasTypeId for Reader<'a,>  {
        #[inline]
        fn type_id() -> u64 { _private::TYPE_ID }
      }
      impl <'a,> ::capnp::traits::FromStructReader<'a> for Reader<'a,>  {
        fn new(reader: ::capnp::private::layout::StructReader<'a>) -> Reader<'a,> {
          Reader { reader: reader,  }
        }
      }

      impl <'a,> ::capnp::traits::FromPointerReader<'a> for Reader<'a,>  {
        fn get_from_pointer(reader: &::capnp::private::layout::PointerReader<'a>) -> ::capnp::Result<Reader<'a,>> {
          ::std::result::Result::Ok(::capnp::traits::FromStructReader::new(try!(reader.get_struct(::std::ptr::null()))))
        }
      }

      impl <'a,> ::capnp::traits::Imbue<'a> for Reader<'a,>  {
        fn imbue(&mut self, cap_table: &'a ::capnp::private::layout::CapTable) {
          self.reader.imbue(::capnp::private::layout::CapTableReader::Plain(cap_table))
        }
      }

      impl <'a,> Reader<'a,>  {
        pub fn reborrow<'b>(&'b self) -> Reader<'b,> {
          Reader { .. *self }
        }

        pub fn total_size(&self) -> ::capnp::Result<::capnp::MessageSize> {
          self.reader.total_size()
        }
        #[inline]
        pub fn get_type(self) -> ::std::result::Result<::data_capnp::FileType,::capnp::NotInSchema> {
          ::capnp::traits::FromU16::from_u16(self.reader.get_data_field::<u16>(0))
        }
      }

      pub struct Builder<'a> { builder: ::capnp::private::layout::StructBuilder<'a> }
      impl <'a,> ::capnp::traits::HasStructSize for Builder<'a,>  {
        #[inline]
        fn struct_size() -> ::capnp::private::layout::StructSize { _private::STRUCT_SIZE }
      }
      impl <'a,> ::capnp::traits::HasTypeId for Builder<'a,>  {
        #[inline]
        fn type_id() -> u64 { _private::TYPE_ID }
      }
      impl <'a,> ::capnp::traits::FromStructBuilder<'a> for Builder<'a,>  {
        fn new(builder: ::capnp::private::layout::StructBuilder<'a>) -> Builder<'a, > {
          Builder { builder: builder,  }
        }
      }

      impl <'a,> ::capnp::traits::ImbueMut<'a> for Builder<'a,>  {
        fn imbue_mut(&mut self, cap_table: &'a mut ::capnp::private::layout::CapTable) {
          self.builder.imbue(::capnp::private::layout::CapTableBuilder::Plain(cap_table))
        }
      }

      impl <'a,> ::capnp::traits::FromPointerBuilder<'a> for Builder<'a,>  {
        fn init_pointer(builder: ::capnp::private::layout::PointerBuilder<'a>, _size: u32) -> Builder<'a,> {
          ::capnp::traits::FromStructBuilder::new(builder.init_struct(_private::STRUCT_SIZE))
        }
        fn get_from_pointer(builder: ::capnp::private::layout::PointerBuilder<'a>) -> ::capnp::Result<Builder<'a,>> {
          ::std::result::Result::Ok(::capnp::traits::FromStructBuilder::new(try!(builder.get_struct(_private::STRUCT_SIZE, ::std::ptr::null()))))
        }
      }

      impl <'a,> ::capnp::traits::SetPointerBuilder<Builder<'a,>> for Reader<'a,>  {
        fn set_pointer_builder<'b>(pointer: ::capnp::private::layout::PointerBuilder<'b>, value: Reader<'a,>, canonicalize: bool) -> ::capnp::Result<()> { pointer.set_struct(&value.reader, canonicalize) }
      }

      impl <'a,> Builder<'a,>  {
        pub fn as_reader(self) -> Reader<'a,> {
          ::capnp::traits::FromStructReader::new(self.builder.as_reader())
        }
        pub fn reborrow<'b>(&'b mut self) -> Builder<'b,> {
          Builder { .. *self }
        }
        pub fn reborrow_as_reader<'b>(&'b self) -> Reader<'b,> {
          ::capnp::traits::FromStructReader::new(self.builder.as_reader())
        }

        pub fn total_size(&self) -> ::capnp::Result<::capnp::MessageSize> {
          self.builder.as_reader().total_size()
        }
        #[inline]
        pub fn get_type(self) -> ::std::result::Result<::data_capnp::FileType,::capnp::NotInSchema> {
          ::capnp::traits::FromU16::from_u16(self.builder.get_data_field::<u16>(0))
        }
        #[inline]
        pub fn set_type(&mut self, value: ::data_capnp::FileType)  {
          self.builder.set_data_field::<u16>(0, value as u16)
        }
      }

      pub struct Pipeline { _typeless: ::capnp::any_pointer::Pipeline }
      impl ::capnp::capability::FromTypelessPipeline for Pipeline {
        fn new(typeless: ::capnp::any_pointer::Pipeline) -> Pipeline {
          Pipeline { _typeless: typeless,  }
        }
      }
      impl Pipeline  {
      }
      mod _private {
        use capnp::private::layout;
        pub const STRUCT_SIZE: layout::StructSize = layout::StructSize { data: 1, pointers: 0 };
        pub const TYPE_ID: u64 = 0x81daebe6677f69cd;
      }
    }
  }


  pub mod listener {
    #![allow(unused_variables)]
    pub type SyncParams<> = ::capnp::capability::Params<::service_capnp::file_tracker::listener::sync_params::Owned>;
    pub type SyncResults<> = ::capnp::capability::Results<::service_capnp::file_tracker::listener::sync_results::Owned>;
    pub type FileUpdateParams<> = ::capnp::capability::Params<::service_capnp::file_tracker::listener::file_update_params::Owned>;
    pub type FileUpdateResults<> = ::capnp::capability::Results<::service_capnp::file_tracker::listener::file_update_results::Owned>;

    pub struct Client {
      pub client: ::capnp::capability::Client,
    }
    impl  ::capnp::capability::FromClientHook for Client {
      fn new(hook: Box<::capnp::private::capability::ClientHook>) -> Client {
        Client { client: ::capnp::capability::Client::new(hook),  }
      }
    }
    #[derive(Copy, Clone)]
    pub struct Owned;
    impl <'a> ::capnp::traits::Owned<'a> for Owned { type Reader = Client; type Builder = Client; }
    impl ::capnp::traits::Pipelined for Owned { type Pipeline = Client; }
    impl <'a,> ::capnp::traits::FromPointerReader<'a> for Client<>  {
      fn get_from_pointer(reader: &::capnp::private::layout::PointerReader<'a>) -> ::capnp::Result<Client<>> {
        ::std::result::Result::Ok(::capnp::capability::FromClientHook::new(try!(reader.get_capability())))
      }
    }
    impl <'a,> ::capnp::traits::FromPointerBuilder<'a> for Client<>  {
      fn init_pointer(_builder: ::capnp::private::layout::PointerBuilder<'a>, _size: u32) -> Client<> {
        unimplemented!()
      }
      fn get_from_pointer(builder: ::capnp::private::layout::PointerBuilder<'a>) -> ::capnp::Result<Client<>> {
        ::std::result::Result::Ok(::capnp::capability::FromClientHook::new(try!(builder.get_capability())))
      }
    }

    impl <> ::capnp::traits::SetPointerBuilder<Client<>> for Client<>  {
      fn set_pointer_builder<'a>(pointer: ::capnp::private::layout::PointerBuilder<'a>, from: Client<>, _canonicalize: bool) -> ::capnp::Result<()> {
        ::std::result::Result::Ok(pointer.set_capability(from.client.hook))
      }
    }
    pub struct ToClient<U>{pub u: U}
    impl <U: Server + 'static> ToClient<U> {
    pub fn new(u: U) -> ToClient<U> { ToClient {u: u} }
      pub fn from_server<_T: ::capnp::private::capability::ServerHook>(self) -> Client {
        Client { client: _T::new_client(::std::boxed::Box::new(ServerDispatch { server: ::std::boxed::Box::new(self.u),  })),  }
      }
    }
    impl  ::capnp::traits::HasTypeId for Client {
      #[inline]
      fn type_id() -> u64 { _private::TYPE_ID }
    }
    impl  Clone for Client {
      fn clone(&self) -> Client {
        Client { client: ::capnp::capability::Client::new(self.client.hook.add_ref()),  }
      }
    }
    impl  Client {
      pub fn sync_request(&self) -> ::capnp::capability::Request<::service_capnp::file_tracker::listener::sync_params::Owned,::service_capnp::file_tracker::listener::sync_results::Owned> {
        self.client.new_call(_private::TYPE_ID, 0, None)
      }
      pub fn file_update_request(&self) -> ::capnp::capability::Request<::service_capnp::file_tracker::listener::file_update_params::Owned,::service_capnp::file_tracker::listener::file_update_results::Owned> {
        self.client.new_call(_private::TYPE_ID, 1, None)
      }
    }
    pub trait Server<>  {
      fn sync(&mut self, _: SyncParams<>, _: SyncResults<>) -> ::capnp::capability::Promise<(), ::capnp::Error> { ::capnp::capability::Promise::err(::capnp::Error::unimplemented("method not implemented".to_string())) }
      fn file_update(&mut self, _: FileUpdateParams<>, _: FileUpdateResults<>) -> ::capnp::capability::Promise<(), ::capnp::Error> { ::capnp::capability::Promise::err(::capnp::Error::unimplemented("method not implemented".to_string())) }
    }
    pub struct ServerDispatch<_T,> {
      pub server: Box<_T>,
    }
    impl <_T: Server> ::capnp::capability::Server for ServerDispatch<_T> {
      fn dispatch_call(&mut self, interface_id: u64, method_id: u16, params: ::capnp::capability::Params<::capnp::any_pointer::Owned>, results: ::capnp::capability::Results<::capnp::any_pointer::Owned>) -> ::capnp::capability::Promise<(), ::capnp::Error> {
        match interface_id {
          _private::TYPE_ID => ServerDispatch::<_T, >::dispatch_call_internal(&mut *self.server, method_id, params, results),
          _ => { ::capnp::capability::Promise::err(::capnp::Error::unimplemented("Method not implemented.".to_string())) }
        }
      }
    }
    impl <_T :Server> ServerDispatch<_T> {
      pub fn dispatch_call_internal(server: &mut _T, method_id: u16, params: ::capnp::capability::Params<::capnp::any_pointer::Owned>, results: ::capnp::capability::Results<::capnp::any_pointer::Owned>) -> ::capnp::capability::Promise<(), ::capnp::Error> {
        match method_id {
          0 => server.sync(::capnp::private::capability::internal_get_typed_params(params), ::capnp::private::capability::internal_get_typed_results(results)),
          1 => server.file_update(::capnp::private::capability::internal_get_typed_params(params), ::capnp::private::capability::internal_get_typed_results(results)),
          _ => { ::capnp::capability::Promise::err(::capnp::Error::unimplemented("Method not implemented.".to_string())) }
        }
      }
    }
    pub mod _private {
      pub const TYPE_ID: u64 = 0xf23830ba3ded4604;
    }

    pub mod sync_params {
      #[derive(Copy, Clone)]
      pub struct Owned;
      impl <'a> ::capnp::traits::Owned<'a> for Owned { type Reader = Reader<'a>; type Builder = Builder<'a>; }
      impl <'a> ::capnp::traits::OwnedStruct<'a> for Owned { type Reader = Reader<'a>; type Builder = Builder<'a>; }
      impl ::capnp::traits::Pipelined for Owned { type Pipeline = Pipeline; }

      #[derive(Clone, Copy)]
      pub struct Reader<'a> { reader: ::capnp::private::layout::StructReader<'a> }

      impl <'a,> ::capnp::traits::HasTypeId for Reader<'a,>  {
        #[inline]
        fn type_id() -> u64 { _private::TYPE_ID }
      }
      impl <'a,> ::capnp::traits::FromStructReader<'a> for Reader<'a,>  {
        fn new(reader: ::capnp::private::layout::StructReader<'a>) -> Reader<'a,> {
          Reader { reader: reader,  }
        }
      }

      impl <'a,> ::capnp::traits::FromPointerReader<'a> for Reader<'a,>  {
        fn get_from_pointer(reader: &::capnp::private::layout::PointerReader<'a>) -> ::capnp::Result<Reader<'a,>> {
          ::std::result::Result::Ok(::capnp::traits::FromStructReader::new(try!(reader.get_struct(::std::ptr::null()))))
        }
      }

      impl <'a,> ::capnp::traits::Imbue<'a> for Reader<'a,>  {
        fn imbue(&mut self, cap_table: &'a ::capnp::private::layout::CapTable) {
          self.reader.imbue(::capnp::private::layout::CapTableReader::Plain(cap_table))
        }
      }

      impl <'a,> Reader<'a,>  {
        pub fn reborrow<'b>(&'b self) -> Reader<'b,> {
          Reader { .. *self }
        }

        pub fn total_size(&self) -> ::capnp::Result<::capnp::MessageSize> {
          self.reader.total_size()
        }
        #[inline]
        pub fn get_files(self) -> ::capnp::Result<::capnp::struct_list::Reader<'a,::service_capnp::file_state::Owned>> {
          ::capnp::traits::FromPointerReader::get_from_pointer(&self.reader.get_pointer_field(0))
        }
        pub fn has_files(&self) -> bool {
          !self.reader.get_pointer_field(0).is_null()
        }
        #[inline]
        pub fn get_snapshot(self) -> ::capnp::Result<::service_capnp::file_tracker::snapshot::Client> {
          match self.reader.get_pointer_field(1).get_capability() { ::std::result::Result::Ok(c) => ::std::result::Result::Ok(::capnp::capability::FromClientHook::new(c)), ::std::result::Result::Err(e) => ::std::result::Result::Err(e)}
        }
      }

      pub struct Builder<'a> { builder: ::capnp::private::layout::StructBuilder<'a> }
      impl <'a,> ::capnp::traits::HasStructSize for Builder<'a,>  {
        #[inline]
        fn struct_size() -> ::capnp::private::layout::StructSize { _private::STRUCT_SIZE }
      }
      impl <'a,> ::capnp::traits::HasTypeId for Builder<'a,>  {
        #[inline]
        fn type_id() -> u64 { _private::TYPE_ID }
      }
      impl <'a,> ::capnp::traits::FromStructBuilder<'a> for Builder<'a,>  {
        fn new(builder: ::capnp::private::layout::StructBuilder<'a>) -> Builder<'a, > {
          Builder { builder: builder,  }
        }
      }

      impl <'a,> ::capnp::traits::ImbueMut<'a> for Builder<'a,>  {
        fn imbue_mut(&mut self, cap_table: &'a mut ::capnp::private::layout::CapTable) {
          self.builder.imbue(::capnp::private::layout::CapTableBuilder::Plain(cap_table))
        }
      }

      impl <'a,> ::capnp::traits::FromPointerBuilder<'a> for Builder<'a,>  {
        fn init_pointer(builder: ::capnp::private::layout::PointerBuilder<'a>, _size: u32) -> Builder<'a,> {
          ::capnp::traits::FromStructBuilder::new(builder.init_struct(_private::STRUCT_SIZE))
        }
        fn get_from_pointer(builder: ::capnp::private::layout::PointerBuilder<'a>) -> ::capnp::Result<Builder<'a,>> {
          ::std::result::Result::Ok(::capnp::traits::FromStructBuilder::new(try!(builder.get_struct(_private::STRUCT_SIZE, ::std::ptr::null()))))
        }
      }

      impl <'a,> ::capnp::traits::SetPointerBuilder<Builder<'a,>> for Reader<'a,>  {
        fn set_pointer_builder<'b>(pointer: ::capnp::private::layout::PointerBuilder<'b>, value: Reader<'a,>, canonicalize: bool) -> ::capnp::Result<()> { pointer.set_struct(&value.reader, canonicalize) }
      }

      impl <'a,> Builder<'a,>  {
        pub fn as_reader(self) -> Reader<'a,> {
          ::capnp::traits::FromStructReader::new(self.builder.as_reader())
        }
        pub fn reborrow<'b>(&'b mut self) -> Builder<'b,> {
          Builder { .. *self }
        }
        pub fn reborrow_as_reader<'b>(&'b self) -> Reader<'b,> {
          ::capnp::traits::FromStructReader::new(self.builder.as_reader())
        }

        pub fn total_size(&self) -> ::capnp::Result<::capnp::MessageSize> {
          self.builder.as_reader().total_size()
        }
        #[inline]
        pub fn get_files(self) -> ::capnp::Result<::capnp::struct_list::Builder<'a,::service_capnp::file_state::Owned>> {
          ::capnp::traits::FromPointerBuilder::get_from_pointer(self.builder.get_pointer_field(0))
        }
        #[inline]
        pub fn set_files(&mut self, value: ::capnp::struct_list::Reader<'a,::service_capnp::file_state::Owned>) -> ::capnp::Result<()> {
          ::capnp::traits::SetPointerBuilder::set_pointer_builder(self.builder.get_pointer_field(0), value, false)
        }
        #[inline]
        pub fn init_files(self, size: u32) -> ::capnp::struct_list::Builder<'a,::service_capnp::file_state::Owned> {
          ::capnp::traits::FromPointerBuilder::init_pointer(self.builder.get_pointer_field(0), size)
        }
        pub fn has_files(&self) -> bool {
          !self.builder.get_pointer_field(0).is_null()
        }
        #[inline]
        pub fn get_snapshot(self) -> ::capnp::Result<::service_capnp::file_tracker::snapshot::Client> {
          match self.builder.get_pointer_field(1).get_capability() { ::std::result::Result::Ok(c) => ::std::result::Result::Ok(::capnp::capability::FromClientHook::new(c)), ::std::result::Result::Err(e) => ::std::result::Result::Err(e)}
        }
        #[inline]
        pub fn set_snapshot(&mut self, value: ::service_capnp::file_tracker::snapshot::Client)  {
          self.builder.get_pointer_field(1).set_capability(value.client.hook);
        }
      }

      pub struct Pipeline { _typeless: ::capnp::any_pointer::Pipeline }
      impl ::capnp::capability::FromTypelessPipeline for Pipeline {
        fn new(typeless: ::capnp::any_pointer::Pipeline) -> Pipeline {
          Pipeline { _typeless: typeless,  }
        }
      }
      impl Pipeline  {
        pub fn get_snapshot(&self) -> ::service_capnp::file_tracker::snapshot::Client {
          ::capnp::capability::FromClientHook::new(self._typeless.get_pointer_field(1).as_cap())
        }
      }
      mod _private {
        use capnp::private::layout;
        pub const STRUCT_SIZE: layout::StructSize = layout::StructSize { data: 0, pointers: 2 };
        pub const TYPE_ID: u64 = 0xc4679aca478d0176;
      }
    }

    pub mod sync_results {
      #[derive(Copy, Clone)]
      pub struct Owned;
      impl <'a> ::capnp::traits::Owned<'a> for Owned { type Reader = Reader<'a>; type Builder = Builder<'a>; }
      impl <'a> ::capnp::traits::OwnedStruct<'a> for Owned { type Reader = Reader<'a>; type Builder = Builder<'a>; }
      impl ::capnp::traits::Pipelined for Owned { type Pipeline = Pipeline; }

      #[derive(Clone, Copy)]
      pub struct Reader<'a> { reader: ::capnp::private::layout::StructReader<'a> }

      impl <'a,> ::capnp::traits::HasTypeId for Reader<'a,>  {
        #[inline]
        fn type_id() -> u64 { _private::TYPE_ID }
      }
      impl <'a,> ::capnp::traits::FromStructReader<'a> for Reader<'a,>  {
        fn new(reader: ::capnp::private::layout::StructReader<'a>) -> Reader<'a,> {
          Reader { reader: reader,  }
        }
      }

      impl <'a,> ::capnp::traits::FromPointerReader<'a> for Reader<'a,>  {
        fn get_from_pointer(reader: &::capnp::private::layout::PointerReader<'a>) -> ::capnp::Result<Reader<'a,>> {
          ::std::result::Result::Ok(::capnp::traits::FromStructReader::new(try!(reader.get_struct(::std::ptr::null()))))
        }
      }

      impl <'a,> ::capnp::traits::Imbue<'a> for Reader<'a,>  {
        fn imbue(&mut self, cap_table: &'a ::capnp::private::layout::CapTable) {
          self.reader.imbue(::capnp::private::layout::CapTableReader::Plain(cap_table))
        }
      }

      impl <'a,> Reader<'a,>  {
        pub fn reborrow<'b>(&'b self) -> Reader<'b,> {
          Reader { .. *self }
        }

        pub fn total_size(&self) -> ::capnp::Result<::capnp::MessageSize> {
          self.reader.total_size()
        }
      }

      pub struct Builder<'a> { builder: ::capnp::private::layout::StructBuilder<'a> }
      impl <'a,> ::capnp::traits::HasStructSize for Builder<'a,>  {
        #[inline]
        fn struct_size() -> ::capnp::private::layout::StructSize { _private::STRUCT_SIZE }
      }
      impl <'a,> ::capnp::traits::HasTypeId for Builder<'a,>  {
        #[inline]
        fn type_id() -> u64 { _private::TYPE_ID }
      }
      impl <'a,> ::capnp::traits::FromStructBuilder<'a> for Builder<'a,>  {
        fn new(builder: ::capnp::private::layout::StructBuilder<'a>) -> Builder<'a, > {
          Builder { builder: builder,  }
        }
      }

      impl <'a,> ::capnp::traits::ImbueMut<'a> for Builder<'a,>  {
        fn imbue_mut(&mut self, cap_table: &'a mut ::capnp::private::layout::CapTable) {
          self.builder.imbue(::capnp::private::layout::CapTableBuilder::Plain(cap_table))
        }
      }

      impl <'a,> ::capnp::traits::FromPointerBuilder<'a> for Builder<'a,>  {
        fn init_pointer(builder: ::capnp::private::layout::PointerBuilder<'a>, _size: u32) -> Builder<'a,> {
          ::capnp::traits::FromStructBuilder::new(builder.init_struct(_private::STRUCT_SIZE))
        }
        fn get_from_pointer(builder: ::capnp::private::layout::PointerBuilder<'a>) -> ::capnp::Result<Builder<'a,>> {
          ::std::result::Result::Ok(::capnp::traits::FromStructBuilder::new(try!(builder.get_struct(_private::STRUCT_SIZE, ::std::ptr::null()))))
        }
      }

      impl <'a,> ::capnp::traits::SetPointerBuilder<Builder<'a,>> for Reader<'a,>  {
        fn set_pointer_builder<'b>(pointer: ::capnp::private::layout::PointerBuilder<'b>, value: Reader<'a,>, canonicalize: bool) -> ::capnp::Result<()> { pointer.set_struct(&value.reader, canonicalize) }
      }

      impl <'a,> Builder<'a,>  {
        pub fn as_reader(self) -> Reader<'a,> {
          ::capnp::traits::FromStructReader::new(self.builder.as_reader())
        }
        pub fn reborrow<'b>(&'b mut self) -> Builder<'b,> {
          Builder { .. *self }
        }
        pub fn reborrow_as_reader<'b>(&'b self) -> Reader<'b,> {
          ::capnp::traits::FromStructReader::new(self.builder.as_reader())
        }

        pub fn total_size(&self) -> ::capnp::Result<::capnp::MessageSize> {
          self.builder.as_reader().total_size()
        }
      }

      pub struct Pipeline { _typeless: ::capnp::any_pointer::Pipeline }
      impl ::capnp::capability::FromTypelessPipeline for Pipeline {
        fn new(typeless: ::capnp::any_pointer::Pipeline) -> Pipeline {
          Pipeline { _typeless: typeless,  }
        }
      }
      impl Pipeline  {
      }
      mod _private {
        use capnp::private::layout;
        pub const STRUCT_SIZE: layout::StructSize = layout::StructSize { data: 0, pointers: 0 };
        pub const TYPE_ID: u64 = 0xf7875d9b797fc01b;
      }
    }

    pub mod file_update_params {
      #[derive(Copy, Clone)]
      pub struct Owned;
      impl <'a> ::capnp::traits::Owned<'a> for Owned { type Reader = Reader<'a>; type Builder = Builder<'a>; }
      impl <'a> ::capnp::traits::OwnedStruct<'a> for Owned { type Reader = Reader<'a>; type Builder = Builder<'a>; }
      impl ::capnp::traits::Pipelined for Owned { type Pipeline = Pipeline; }

      #[derive(Clone, Copy)]
      pub struct Reader<'a> { reader: ::capnp::private::layout::StructReader<'a> }

      impl <'a,> ::capnp::traits::HasTypeId for Reader<'a,>  {
        #[inline]
        fn type_id() -> u64 { _private::TYPE_ID }
      }
      impl <'a,> ::capnp::traits::FromStructReader<'a> for Reader<'a,>  {
        fn new(reader: ::capnp::private::layout::StructReader<'a>) -> Reader<'a,> {
          Reader { reader: reader,  }
        }
      }

      impl <'a,> ::capnp::traits::FromPointerReader<'a> for Reader<'a,>  {
        fn get_from_pointer(reader: &::capnp::private::layout::PointerReader<'a>) -> ::capnp::Result<Reader<'a,>> {
          ::std::result::Result::Ok(::capnp::traits::FromStructReader::new(try!(reader.get_struct(::std::ptr::null()))))
        }
      }

      impl <'a,> ::capnp::traits::Imbue<'a> for Reader<'a,>  {
        fn imbue(&mut self, cap_table: &'a ::capnp::private::layout::CapTable) {
          self.reader.imbue(::capnp::private::layout::CapTableReader::Plain(cap_table))
        }
      }

      impl <'a,> Reader<'a,>  {
        pub fn reborrow<'b>(&'b self) -> Reader<'b,> {
          Reader { .. *self }
        }

        pub fn total_size(&self) -> ::capnp::Result<::capnp::MessageSize> {
          self.reader.total_size()
        }
        #[inline]
        pub fn get_updated_files(self) -> ::capnp::Result<::capnp::struct_list::Reader<'a,::service_capnp::file_state::Owned>> {
          ::capnp::traits::FromPointerReader::get_from_pointer(&self.reader.get_pointer_field(0))
        }
        pub fn has_updated_files(&self) -> bool {
          !self.reader.get_pointer_field(0).is_null()
        }
        #[inline]
        pub fn get_snapshot(self) -> ::capnp::Result<::service_capnp::file_tracker::snapshot::Client> {
          match self.reader.get_pointer_field(1).get_capability() { ::std::result::Result::Ok(c) => ::std::result::Result::Ok(::capnp::capability::FromClientHook::new(c)), ::std::result::Result::Err(e) => ::std::result::Result::Err(e)}
        }
      }

      pub struct Builder<'a> { builder: ::capnp::private::layout::StructBuilder<'a> }
      impl <'a,> ::capnp::traits::HasStructSize for Builder<'a,>  {
        #[inline]
        fn struct_size() -> ::capnp::private::layout::StructSize { _private::STRUCT_SIZE }
      }
      impl <'a,> ::capnp::traits::HasTypeId for Builder<'a,>  {
        #[inline]
        fn type_id() -> u64 { _private::TYPE_ID }
      }
      impl <'a,> ::capnp::traits::FromStructBuilder<'a> for Builder<'a,>  {
        fn new(builder: ::capnp::private::layout::StructBuilder<'a>) -> Builder<'a, > {
          Builder { builder: builder,  }
        }
      }

      impl <'a,> ::capnp::traits::ImbueMut<'a> for Builder<'a,>  {
        fn imbue_mut(&mut self, cap_table: &'a mut ::capnp::private::layout::CapTable) {
          self.builder.imbue(::capnp::private::layout::CapTableBuilder::Plain(cap_table))
        }
      }

      impl <'a,> ::capnp::traits::FromPointerBuilder<'a> for Builder<'a,>  {
        fn init_pointer(builder: ::capnp::private::layout::PointerBuilder<'a>, _size: u32) -> Builder<'a,> {
          ::capnp::traits::FromStructBuilder::new(builder.init_struct(_private::STRUCT_SIZE))
        }
        fn get_from_pointer(builder: ::capnp::private::layout::PointerBuilder<'a>) -> ::capnp::Result<Builder<'a,>> {
          ::std::result::Result::Ok(::capnp::traits::FromStructBuilder::new(try!(builder.get_struct(_private::STRUCT_SIZE, ::std::ptr::null()))))
        }
      }

      impl <'a,> ::capnp::traits::SetPointerBuilder<Builder<'a,>> for Reader<'a,>  {
        fn set_pointer_builder<'b>(pointer: ::capnp::private::layout::PointerBuilder<'b>, value: Reader<'a,>, canonicalize: bool) -> ::capnp::Result<()> { pointer.set_struct(&value.reader, canonicalize) }
      }

      impl <'a,> Builder<'a,>  {
        pub fn as_reader(self) -> Reader<'a,> {
          ::capnp::traits::FromStructReader::new(self.builder.as_reader())
        }
        pub fn reborrow<'b>(&'b mut self) -> Builder<'b,> {
          Builder { .. *self }
        }
        pub fn reborrow_as_reader<'b>(&'b self) -> Reader<'b,> {
          ::capnp::traits::FromStructReader::new(self.builder.as_reader())
        }

        pub fn total_size(&self) -> ::capnp::Result<::capnp::MessageSize> {
          self.builder.as_reader().total_size()
        }
        #[inline]
        pub fn get_updated_files(self) -> ::capnp::Result<::capnp::struct_list::Builder<'a,::service_capnp::file_state::Owned>> {
          ::capnp::traits::FromPointerBuilder::get_from_pointer(self.builder.get_pointer_field(0))
        }
        #[inline]
        pub fn set_updated_files(&mut self, value: ::capnp::struct_list::Reader<'a,::service_capnp::file_state::Owned>) -> ::capnp::Result<()> {
          ::capnp::traits::SetPointerBuilder::set_pointer_builder(self.builder.get_pointer_field(0), value, false)
        }
        #[inline]
        pub fn init_updated_files(self, size: u32) -> ::capnp::struct_list::Builder<'a,::service_capnp::file_state::Owned> {
          ::capnp::traits::FromPointerBuilder::init_pointer(self.builder.get_pointer_field(0), size)
        }
        pub fn has_updated_files(&self) -> bool {
          !self.builder.get_pointer_field(0).is_null()
        }
        #[inline]
        pub fn get_snapshot(self) -> ::capnp::Result<::service_capnp::file_tracker::snapshot::Client> {
          match self.builder.get_pointer_field(1).get_capability() { ::std::result::Result::Ok(c) => ::std::result::Result::Ok(::capnp::capability::FromClientHook::new(c)), ::std::result::Result::Err(e) => ::std::result::Result::Err(e)}
        }
        #[inline]
        pub fn set_snapshot(&mut self, value: ::service_capnp::file_tracker::snapshot::Client)  {
          self.builder.get_pointer_field(1).set_capability(value.client.hook);
        }
      }

      pub struct Pipeline { _typeless: ::capnp::any_pointer::Pipeline }
      impl ::capnp::capability::FromTypelessPipeline for Pipeline {
        fn new(typeless: ::capnp::any_pointer::Pipeline) -> Pipeline {
          Pipeline { _typeless: typeless,  }
        }
      }
      impl Pipeline  {
        pub fn get_snapshot(&self) -> ::service_capnp::file_tracker::snapshot::Client {
          ::capnp::capability::FromClientHook::new(self._typeless.get_pointer_field(1).as_cap())
        }
      }
      mod _private {
        use capnp::private::layout;
        pub const STRUCT_SIZE: layout::StructSize = layout::StructSize { data: 0, pointers: 2 };
        pub const TYPE_ID: u64 = 0x8bafd32f6c3e86fb;
      }
    }

    pub mod file_update_results {
      #[derive(Copy, Clone)]
      pub struct Owned;
      impl <'a> ::capnp::traits::Owned<'a> for Owned { type Reader = Reader<'a>; type Builder = Builder<'a>; }
      impl <'a> ::capnp::traits::OwnedStruct<'a> for Owned { type Reader = Reader<'a>; type Builder = Builder<'a>; }
      impl ::capnp::traits::Pipelined for Owned { type Pipeline = Pipeline; }

      #[derive(Clone, Copy)]
      pub struct Reader<'a> { reader: ::capnp::private::layout::StructReader<'a> }

      impl <'a,> ::capnp::traits::HasTypeId for Reader<'a,>  {
        #[inline]
        fn type_id() -> u64 { _private::TYPE_ID }
      }
      impl <'a,> ::capnp::traits::FromStructReader<'a> for Reader<'a,>  {
        fn new(reader: ::capnp::private::layout::StructReader<'a>) -> Reader<'a,> {
          Reader { reader: reader,  }
        }
      }

      impl <'a,> ::capnp::traits::FromPointerReader<'a> for Reader<'a,>  {
        fn get_from_pointer(reader: &::capnp::private::layout::PointerReader<'a>) -> ::capnp::Result<Reader<'a,>> {
          ::std::result::Result::Ok(::capnp::traits::FromStructReader::new(try!(reader.get_struct(::std::ptr::null()))))
        }
      }

      impl <'a,> ::capnp::traits::Imbue<'a> for Reader<'a,>  {
        fn imbue(&mut self, cap_table: &'a ::capnp::private::layout::CapTable) {
          self.reader.imbue(::capnp::private::layout::CapTableReader::Plain(cap_table))
        }
      }

      impl <'a,> Reader<'a,>  {
        pub fn reborrow<'b>(&'b self) -> Reader<'b,> {
          Reader { .. *self }
        }

        pub fn total_size(&self) -> ::capnp::Result<::capnp::MessageSize> {
          self.reader.total_size()
        }
      }

      pub struct Builder<'a> { builder: ::capnp::private::layout::StructBuilder<'a> }
      impl <'a,> ::capnp::traits::HasStructSize for Builder<'a,>  {
        #[inline]
        fn struct_size() -> ::capnp::private::layout::StructSize { _private::STRUCT_SIZE }
      }
      impl <'a,> ::capnp::traits::HasTypeId for Builder<'a,>  {
        #[inline]
        fn type_id() -> u64 { _private::TYPE_ID }
      }
      impl <'a,> ::capnp::traits::FromStructBuilder<'a> for Builder<'a,>  {
        fn new(builder: ::capnp::private::layout::StructBuilder<'a>) -> Builder<'a, > {
          Builder { builder: builder,  }
        }
      }

      impl <'a,> ::capnp::traits::ImbueMut<'a> for Builder<'a,>  {
        fn imbue_mut(&mut self, cap_table: &'a mut ::capnp::private::layout::CapTable) {
          self.builder.imbue(::capnp::private::layout::CapTableBuilder::Plain(cap_table))
        }
      }

      impl <'a,> ::capnp::traits::FromPointerBuilder<'a> for Builder<'a,>  {
        fn init_pointer(builder: ::capnp::private::layout::PointerBuilder<'a>, _size: u32) -> Builder<'a,> {
          ::capnp::traits::FromStructBuilder::new(builder.init_struct(_private::STRUCT_SIZE))
        }
        fn get_from_pointer(builder: ::capnp::private::layout::PointerBuilder<'a>) -> ::capnp::Result<Builder<'a,>> {
          ::std::result::Result::Ok(::capnp::traits::FromStructBuilder::new(try!(builder.get_struct(_private::STRUCT_SIZE, ::std::ptr::null()))))
        }
      }

      impl <'a,> ::capnp::traits::SetPointerBuilder<Builder<'a,>> for Reader<'a,>  {
        fn set_pointer_builder<'b>(pointer: ::capnp::private::layout::PointerBuilder<'b>, value: Reader<'a,>, canonicalize: bool) -> ::capnp::Result<()> { pointer.set_struct(&value.reader, canonicalize) }
      }

      impl <'a,> Builder<'a,>  {
        pub fn as_reader(self) -> Reader<'a,> {
          ::capnp::traits::FromStructReader::new(self.builder.as_reader())
        }
        pub fn reborrow<'b>(&'b mut self) -> Builder<'b,> {
          Builder { .. *self }
        }
        pub fn reborrow_as_reader<'b>(&'b self) -> Reader<'b,> {
          ::capnp::traits::FromStructReader::new(self.builder.as_reader())
        }

        pub fn total_size(&self) -> ::capnp::Result<::capnp::MessageSize> {
          self.builder.as_reader().total_size()
        }
      }

      pub struct Pipeline { _typeless: ::capnp::any_pointer::Pipeline }
      impl ::capnp::capability::FromTypelessPipeline for Pipeline {
        fn new(typeless: ::capnp::any_pointer::Pipeline) -> Pipeline {
          Pipeline { _typeless: typeless,  }
        }
      }
      impl Pipeline  {
      }
      mod _private {
        use capnp::private::layout;
        pub const STRUCT_SIZE: layout::StructSize = layout::StructSize { data: 0, pointers: 0 };
        pub const TYPE_ID: u64 = 0xc39e3b5b8986149e;
      }
    }
  }

  pub mod register_listener_params {
    #[derive(Copy, Clone)]
    pub struct Owned;
    impl <'a> ::capnp::traits::Owned<'a> for Owned { type Reader = Reader<'a>; type Builder = Builder<'a>; }
    impl <'a> ::capnp::traits::OwnedStruct<'a> for Owned { type Reader = Reader<'a>; type Builder = Builder<'a>; }
    impl ::capnp::traits::Pipelined for Owned { type Pipeline = Pipeline; }

    #[derive(Clone, Copy)]
    pub struct Reader<'a> { reader: ::capnp::private::layout::StructReader<'a> }

    impl <'a,> ::capnp::traits::HasTypeId for Reader<'a,>  {
      #[inline]
      fn type_id() -> u64 { _private::TYPE_ID }
    }
    impl <'a,> ::capnp::traits::FromStructReader<'a> for Reader<'a,>  {
      fn new(reader: ::capnp::private::layout::StructReader<'a>) -> Reader<'a,> {
        Reader { reader: reader,  }
      }
    }

    impl <'a,> ::capnp::traits::FromPointerReader<'a> for Reader<'a,>  {
      fn get_from_pointer(reader: &::capnp::private::layout::PointerReader<'a>) -> ::capnp::Result<Reader<'a,>> {
        ::std::result::Result::Ok(::capnp::traits::FromStructReader::new(try!(reader.get_struct(::std::ptr::null()))))
      }
    }

    impl <'a,> ::capnp::traits::Imbue<'a> for Reader<'a,>  {
      fn imbue(&mut self, cap_table: &'a ::capnp::private::layout::CapTable) {
        self.reader.imbue(::capnp::private::layout::CapTableReader::Plain(cap_table))
      }
    }

    impl <'a,> Reader<'a,>  {
      pub fn reborrow<'b>(&'b self) -> Reader<'b,> {
        Reader { .. *self }
      }

      pub fn total_size(&self) -> ::capnp::Result<::capnp::MessageSize> {
        self.reader.total_size()
      }
      #[inline]
      pub fn get_listener(self) -> ::capnp::Result<::service_capnp::file_tracker::listener::Client> {
        match self.reader.get_pointer_field(0).get_capability() { ::std::result::Result::Ok(c) => ::std::result::Result::Ok(::capnp::capability::FromClientHook::new(c)), ::std::result::Result::Err(e) => ::std::result::Result::Err(e)}
      }
    }

    pub struct Builder<'a> { builder: ::capnp::private::layout::StructBuilder<'a> }
    impl <'a,> ::capnp::traits::HasStructSize for Builder<'a,>  {
      #[inline]
      fn struct_size() -> ::capnp::private::layout::StructSize { _private::STRUCT_SIZE }
    }
    impl <'a,> ::capnp::traits::HasTypeId for Builder<'a,>  {
      #[inline]
      fn type_id() -> u64 { _private::TYPE_ID }
    }
    impl <'a,> ::capnp::traits::FromStructBuilder<'a> for Builder<'a,>  {
      fn new(builder: ::capnp::private::layout::StructBuilder<'a>) -> Builder<'a, > {
        Builder { builder: builder,  }
      }
    }

    impl <'a,> ::capnp::traits::ImbueMut<'a> for Builder<'a,>  {
      fn imbue_mut(&mut self, cap_table: &'a mut ::capnp::private::layout::CapTable) {
        self.builder.imbue(::capnp::private::layout::CapTableBuilder::Plain(cap_table))
      }
    }

    impl <'a,> ::capnp::traits::FromPointerBuilder<'a> for Builder<'a,>  {
      fn init_pointer(builder: ::capnp::private::layout::PointerBuilder<'a>, _size: u32) -> Builder<'a,> {
        ::capnp::traits::FromStructBuilder::new(builder.init_struct(_private::STRUCT_SIZE))
      }
      fn get_from_pointer(builder: ::capnp::private::layout::PointerBuilder<'a>) -> ::capnp::Result<Builder<'a,>> {
        ::std::result::Result::Ok(::capnp::traits::FromStructBuilder::new(try!(builder.get_struct(_private::STRUCT_SIZE, ::std::ptr::null()))))
      }
    }

    impl <'a,> ::capnp::traits::SetPointerBuilder<Builder<'a,>> for Reader<'a,>  {
      fn set_pointer_builder<'b>(pointer: ::capnp::private::layout::PointerBuilder<'b>, value: Reader<'a,>, canonicalize: bool) -> ::capnp::Result<()> { pointer.set_struct(&value.reader, canonicalize) }
    }

    impl <'a,> Builder<'a,>  {
      pub fn as_reader(self) -> Reader<'a,> {
        ::capnp::traits::FromStructReader::new(self.builder.as_reader())
      }
      pub fn reborrow<'b>(&'b mut self) -> Builder<'b,> {
        Builder { .. *self }
      }
      pub fn reborrow_as_reader<'b>(&'b self) -> Reader<'b,> {
        ::capnp::traits::FromStructReader::new(self.builder.as_reader())
      }

      pub fn total_size(&self) -> ::capnp::Result<::capnp::MessageSize> {
        self.builder.as_reader().total_size()
      }
      #[inline]
      pub fn get_listener(self) -> ::capnp::Result<::service_capnp::file_tracker::listener::Client> {
        match self.builder.get_pointer_field(0).get_capability() { ::std::result::Result::Ok(c) => ::std::result::Result::Ok(::capnp::capability::FromClientHook::new(c)), ::std::result::Result::Err(e) => ::std::result::Result::Err(e)}
      }
      #[inline]
      pub fn set_listener(&mut self, value: ::service_capnp::file_tracker::listener::Client)  {
        self.builder.get_pointer_field(0).set_capability(value.client.hook);
      }
    }

    pub struct Pipeline { _typeless: ::capnp::any_pointer::Pipeline }
    impl ::capnp::capability::FromTypelessPipeline for Pipeline {
      fn new(typeless: ::capnp::any_pointer::Pipeline) -> Pipeline {
        Pipeline { _typeless: typeless,  }
      }
    }
    impl Pipeline  {
      pub fn get_listener(&self) -> ::service_capnp::file_tracker::listener::Client {
        ::capnp::capability::FromClientHook::new(self._typeless.get_pointer_field(0).as_cap())
      }
    }
    mod _private {
      use capnp::private::layout;
      pub const STRUCT_SIZE: layout::StructSize = layout::StructSize { data: 0, pointers: 1 };
      pub const TYPE_ID: u64 = 0xb083f5a31f492afd;
    }
  }

  pub mod register_listener_results {
    #[derive(Copy, Clone)]
    pub struct Owned;
    impl <'a> ::capnp::traits::Owned<'a> for Owned { type Reader = Reader<'a>; type Builder = Builder<'a>; }
    impl <'a> ::capnp::traits::OwnedStruct<'a> for Owned { type Reader = Reader<'a>; type Builder = Builder<'a>; }
    impl ::capnp::traits::Pipelined for Owned { type Pipeline = Pipeline; }

    #[derive(Clone, Copy)]
    pub struct Reader<'a> { reader: ::capnp::private::layout::StructReader<'a> }

    impl <'a,> ::capnp::traits::HasTypeId for Reader<'a,>  {
      #[inline]
      fn type_id() -> u64 { _private::TYPE_ID }
    }
    impl <'a,> ::capnp::traits::FromStructReader<'a> for Reader<'a,>  {
      fn new(reader: ::capnp::private::layout::StructReader<'a>) -> Reader<'a,> {
        Reader { reader: reader,  }
      }
    }

    impl <'a,> ::capnp::traits::FromPointerReader<'a> for Reader<'a,>  {
      fn get_from_pointer(reader: &::capnp::private::layout::PointerReader<'a>) -> ::capnp::Result<Reader<'a,>> {
        ::std::result::Result::Ok(::capnp::traits::FromStructReader::new(try!(reader.get_struct(::std::ptr::null()))))
      }
    }

    impl <'a,> ::capnp::traits::Imbue<'a> for Reader<'a,>  {
      fn imbue(&mut self, cap_table: &'a ::capnp::private::layout::CapTable) {
        self.reader.imbue(::capnp::private::layout::CapTableReader::Plain(cap_table))
      }
    }

    impl <'a,> Reader<'a,>  {
      pub fn reborrow<'b>(&'b self) -> Reader<'b,> {
        Reader { .. *self }
      }

      pub fn total_size(&self) -> ::capnp::Result<::capnp::MessageSize> {
        self.reader.total_size()
      }
    }

    pub struct Builder<'a> { builder: ::capnp::private::layout::StructBuilder<'a> }
    impl <'a,> ::capnp::traits::HasStructSize for Builder<'a,>  {
      #[inline]
      fn struct_size() -> ::capnp::private::layout::StructSize { _private::STRUCT_SIZE }
    }
    impl <'a,> ::capnp::traits::HasTypeId for Builder<'a,>  {
      #[inline]
      fn type_id() -> u64 { _private::TYPE_ID }
    }
    impl <'a,> ::capnp::traits::FromStructBuilder<'a> for Builder<'a,>  {
      fn new(builder: ::capnp::private::layout::StructBuilder<'a>) -> Builder<'a, > {
        Builder { builder: builder,  }
      }
    }

    impl <'a,> ::capnp::traits::ImbueMut<'a> for Builder<'a,>  {
      fn imbue_mut(&mut self, cap_table: &'a mut ::capnp::private::layout::CapTable) {
        self.builder.imbue(::capnp::private::layout::CapTableBuilder::Plain(cap_table))
      }
    }

    impl <'a,> ::capnp::traits::FromPointerBuilder<'a> for Builder<'a,>  {
      fn init_pointer(builder: ::capnp::private::layout::PointerBuilder<'a>, _size: u32) -> Builder<'a,> {
        ::capnp::traits::FromStructBuilder::new(builder.init_struct(_private::STRUCT_SIZE))
      }
      fn get_from_pointer(builder: ::capnp::private::layout::PointerBuilder<'a>) -> ::capnp::Result<Builder<'a,>> {
        ::std::result::Result::Ok(::capnp::traits::FromStructBuilder::new(try!(builder.get_struct(_private::STRUCT_SIZE, ::std::ptr::null()))))
      }
    }

    impl <'a,> ::capnp::traits::SetPointerBuilder<Builder<'a,>> for Reader<'a,>  {
      fn set_pointer_builder<'b>(pointer: ::capnp::private::layout::PointerBuilder<'b>, value: Reader<'a,>, canonicalize: bool) -> ::capnp::Result<()> { pointer.set_struct(&value.reader, canonicalize) }
    }

    impl <'a,> Builder<'a,>  {
      pub fn as_reader(self) -> Reader<'a,> {
        ::capnp::traits::FromStructReader::new(self.builder.as_reader())
      }
      pub fn reborrow<'b>(&'b mut self) -> Builder<'b,> {
        Builder { .. *self }
      }
      pub fn reborrow_as_reader<'b>(&'b self) -> Reader<'b,> {
        ::capnp::traits::FromStructReader::new(self.builder.as_reader())
      }

      pub fn total_size(&self) -> ::capnp::Result<::capnp::MessageSize> {
        self.builder.as_reader().total_size()
      }
    }

    pub struct Pipeline { _typeless: ::capnp::any_pointer::Pipeline }
    impl ::capnp::capability::FromTypelessPipeline for Pipeline {
      fn new(typeless: ::capnp::any_pointer::Pipeline) -> Pipeline {
        Pipeline { _typeless: typeless,  }
      }
    }
    impl Pipeline  {
    }
    mod _private {
      use capnp::private::layout;
      pub const STRUCT_SIZE: layout::StructSize = layout::StructSize { data: 0, pointers: 0 };
      pub const TYPE_ID: u64 = 0xcc2ad269b1222e6e;
    }
  }

  pub mod get_snapshot_params {
    #[derive(Copy, Clone)]
    pub struct Owned;
    impl <'a> ::capnp::traits::Owned<'a> for Owned { type Reader = Reader<'a>; type Builder = Builder<'a>; }
    impl <'a> ::capnp::traits::OwnedStruct<'a> for Owned { type Reader = Reader<'a>; type Builder = Builder<'a>; }
    impl ::capnp::traits::Pipelined for Owned { type Pipeline = Pipeline; }

    #[derive(Clone, Copy)]
    pub struct Reader<'a> { reader: ::capnp::private::layout::StructReader<'a> }

    impl <'a,> ::capnp::traits::HasTypeId for Reader<'a,>  {
      #[inline]
      fn type_id() -> u64 { _private::TYPE_ID }
    }
    impl <'a,> ::capnp::traits::FromStructReader<'a> for Reader<'a,>  {
      fn new(reader: ::capnp::private::layout::StructReader<'a>) -> Reader<'a,> {
        Reader { reader: reader,  }
      }
    }

    impl <'a,> ::capnp::traits::FromPointerReader<'a> for Reader<'a,>  {
      fn get_from_pointer(reader: &::capnp::private::layout::PointerReader<'a>) -> ::capnp::Result<Reader<'a,>> {
        ::std::result::Result::Ok(::capnp::traits::FromStructReader::new(try!(reader.get_struct(::std::ptr::null()))))
      }
    }

    impl <'a,> ::capnp::traits::Imbue<'a> for Reader<'a,>  {
      fn imbue(&mut self, cap_table: &'a ::capnp::private::layout::CapTable) {
        self.reader.imbue(::capnp::private::layout::CapTableReader::Plain(cap_table))
      }
    }

    impl <'a,> Reader<'a,>  {
      pub fn reborrow<'b>(&'b self) -> Reader<'b,> {
        Reader { .. *self }
      }

      pub fn total_size(&self) -> ::capnp::Result<::capnp::MessageSize> {
        self.reader.total_size()
      }
    }

    pub struct Builder<'a> { builder: ::capnp::private::layout::StructBuilder<'a> }
    impl <'a,> ::capnp::traits::HasStructSize for Builder<'a,>  {
      #[inline]
      fn struct_size() -> ::capnp::private::layout::StructSize { _private::STRUCT_SIZE }
    }
    impl <'a,> ::capnp::traits::HasTypeId for Builder<'a,>  {
      #[inline]
      fn type_id() -> u64 { _private::TYPE_ID }
    }
    impl <'a,> ::capnp::traits::FromStructBuilder<'a> for Builder<'a,>  {
      fn new(builder: ::capnp::private::layout::StructBuilder<'a>) -> Builder<'a, > {
        Builder { builder: builder,  }
      }
    }

    impl <'a,> ::capnp::traits::ImbueMut<'a> for Builder<'a,>  {
      fn imbue_mut(&mut self, cap_table: &'a mut ::capnp::private::layout::CapTable) {
        self.builder.imbue(::capnp::private::layout::CapTableBuilder::Plain(cap_table))
      }
    }

    impl <'a,> ::capnp::traits::FromPointerBuilder<'a> for Builder<'a,>  {
      fn init_pointer(builder: ::capnp::private::layout::PointerBuilder<'a>, _size: u32) -> Builder<'a,> {
        ::capnp::traits::FromStructBuilder::new(builder.init_struct(_private::STRUCT_SIZE))
      }
      fn get_from_pointer(builder: ::capnp::private::layout::PointerBuilder<'a>) -> ::capnp::Result<Builder<'a,>> {
        ::std::result::Result::Ok(::capnp::traits::FromStructBuilder::new(try!(builder.get_struct(_private::STRUCT_SIZE, ::std::ptr::null()))))
      }
    }

    impl <'a,> ::capnp::traits::SetPointerBuilder<Builder<'a,>> for Reader<'a,>  {
      fn set_pointer_builder<'b>(pointer: ::capnp::private::layout::PointerBuilder<'b>, value: Reader<'a,>, canonicalize: bool) -> ::capnp::Result<()> { pointer.set_struct(&value.reader, canonicalize) }
    }

    impl <'a,> Builder<'a,>  {
      pub fn as_reader(self) -> Reader<'a,> {
        ::capnp::traits::FromStructReader::new(self.builder.as_reader())
      }
      pub fn reborrow<'b>(&'b mut self) -> Builder<'b,> {
        Builder { .. *self }
      }
      pub fn reborrow_as_reader<'b>(&'b self) -> Reader<'b,> {
        ::capnp::traits::FromStructReader::new(self.builder.as_reader())
      }

      pub fn total_size(&self) -> ::capnp::Result<::capnp::MessageSize> {
        self.builder.as_reader().total_size()
      }
    }

    pub struct Pipeline { _typeless: ::capnp::any_pointer::Pipeline }
    impl ::capnp::capability::FromTypelessPipeline for Pipeline {
      fn new(typeless: ::capnp::any_pointer::Pipeline) -> Pipeline {
        Pipeline { _typeless: typeless,  }
      }
    }
    impl Pipeline  {
    }
    mod _private {
      use capnp::private::layout;
      pub const STRUCT_SIZE: layout::StructSize = layout::StructSize { data: 0, pointers: 0 };
      pub const TYPE_ID: u64 = 0xb29b0beb0832a63b;
    }
  }

  pub mod get_snapshot_results {
    #[derive(Copy, Clone)]
    pub struct Owned;
    impl <'a> ::capnp::traits::Owned<'a> for Owned { type Reader = Reader<'a>; type Builder = Builder<'a>; }
    impl <'a> ::capnp::traits::OwnedStruct<'a> for Owned { type Reader = Reader<'a>; type Builder = Builder<'a>; }
    impl ::capnp::traits::Pipelined for Owned { type Pipeline = Pipeline; }

    #[derive(Clone, Copy)]
    pub struct Reader<'a> { reader: ::capnp::private::layout::StructReader<'a> }

    impl <'a,> ::capnp::traits::HasTypeId for Reader<'a,>  {
      #[inline]
      fn type_id() -> u64 { _private::TYPE_ID }
    }
    impl <'a,> ::capnp::traits::FromStructReader<'a> for Reader<'a,>  {
      fn new(reader: ::capnp::private::layout::StructReader<'a>) -> Reader<'a,> {
        Reader { reader: reader,  }
      }
    }

    impl <'a,> ::capnp::traits::FromPointerReader<'a> for Reader<'a,>  {
      fn get_from_pointer(reader: &::capnp::private::layout::PointerReader<'a>) -> ::capnp::Result<Reader<'a,>> {
        ::std::result::Result::Ok(::capnp::traits::FromStructReader::new(try!(reader.get_struct(::std::ptr::null()))))
      }
    }

    impl <'a,> ::capnp::traits::Imbue<'a> for Reader<'a,>  {
      fn imbue(&mut self, cap_table: &'a ::capnp::private::layout::CapTable) {
        self.reader.imbue(::capnp::private::layout::CapTableReader::Plain(cap_table))
      }
    }

    impl <'a,> Reader<'a,>  {
      pub fn reborrow<'b>(&'b self) -> Reader<'b,> {
        Reader { .. *self }
      }

      pub fn total_size(&self) -> ::capnp::Result<::capnp::MessageSize> {
        self.reader.total_size()
      }
      #[inline]
      pub fn get_snapshot(self) -> ::capnp::Result<::service_capnp::file_tracker::snapshot::Client> {
        match self.reader.get_pointer_field(0).get_capability() { ::std::result::Result::Ok(c) => ::std::result::Result::Ok(::capnp::capability::FromClientHook::new(c)), ::std::result::Result::Err(e) => ::std::result::Result::Err(e)}
      }
    }

    pub struct Builder<'a> { builder: ::capnp::private::layout::StructBuilder<'a> }
    impl <'a,> ::capnp::traits::HasStructSize for Builder<'a,>  {
      #[inline]
      fn struct_size() -> ::capnp::private::layout::StructSize { _private::STRUCT_SIZE }
    }
    impl <'a,> ::capnp::traits::HasTypeId for Builder<'a,>  {
      #[inline]
      fn type_id() -> u64 { _private::TYPE_ID }
    }
    impl <'a,> ::capnp::traits::FromStructBuilder<'a> for Builder<'a,>  {
      fn new(builder: ::capnp::private::layout::StructBuilder<'a>) -> Builder<'a, > {
        Builder { builder: builder,  }
      }
    }

    impl <'a,> ::capnp::traits::ImbueMut<'a> for Builder<'a,>  {
      fn imbue_mut(&mut self, cap_table: &'a mut ::capnp::private::layout::CapTable) {
        self.builder.imbue(::capnp::private::layout::CapTableBuilder::Plain(cap_table))
      }
    }

    impl <'a,> ::capnp::traits::FromPointerBuilder<'a> for Builder<'a,>  {
      fn init_pointer(builder: ::capnp::private::layout::PointerBuilder<'a>, _size: u32) -> Builder<'a,> {
        ::capnp::traits::FromStructBuilder::new(builder.init_struct(_private::STRUCT_SIZE))
      }
      fn get_from_pointer(builder: ::capnp::private::layout::PointerBuilder<'a>) -> ::capnp::Result<Builder<'a,>> {
        ::std::result::Result::Ok(::capnp::traits::FromStructBuilder::new(try!(builder.get_struct(_private::STRUCT_SIZE, ::std::ptr::null()))))
      }
    }

    impl <'a,> ::capnp::traits::SetPointerBuilder<Builder<'a,>> for Reader<'a,>  {
      fn set_pointer_builder<'b>(pointer: ::capnp::private::layout::PointerBuilder<'b>, value: Reader<'a,>, canonicalize: bool) -> ::capnp::Result<()> { pointer.set_struct(&value.reader, canonicalize) }
    }

    impl <'a,> Builder<'a,>  {
      pub fn as_reader(self) -> Reader<'a,> {
        ::capnp::traits::FromStructReader::new(self.builder.as_reader())
      }
      pub fn reborrow<'b>(&'b mut self) -> Builder<'b,> {
        Builder { .. *self }
      }
      pub fn reborrow_as_reader<'b>(&'b self) -> Reader<'b,> {
        ::capnp::traits::FromStructReader::new(self.builder.as_reader())
      }

      pub fn total_size(&self) -> ::capnp::Result<::capnp::MessageSize> {
        self.builder.as_reader().total_size()
      }
      #[inline]
      pub fn get_snapshot(self) -> ::capnp::Result<::service_capnp::file_tracker::snapshot::Client> {
        match self.builder.get_pointer_field(0).get_capability() { ::std::result::Result::Ok(c) => ::std::result::Result::Ok(::capnp::capability::FromClientHook::new(c)), ::std::result::Result::Err(e) => ::std::result::Result::Err(e)}
      }
      #[inline]
      pub fn set_snapshot(&mut self, value: ::service_capnp::file_tracker::snapshot::Client)  {
        self.builder.get_pointer_field(0).set_capability(value.client.hook);
      }
    }

    pub struct Pipeline { _typeless: ::capnp::any_pointer::Pipeline }
    impl ::capnp::capability::FromTypelessPipeline for Pipeline {
      fn new(typeless: ::capnp::any_pointer::Pipeline) -> Pipeline {
        Pipeline { _typeless: typeless,  }
      }
    }
    impl Pipeline  {
      pub fn get_snapshot(&self) -> ::service_capnp::file_tracker::snapshot::Client {
        ::capnp::capability::FromClientHook::new(self._typeless.get_pointer_field(0).as_cap())
      }
    }
    mod _private {
      use capnp::private::layout;
      pub const STRUCT_SIZE: layout::StructSize = layout::StructSize { data: 0, pointers: 1 };
      pub const TYPE_ID: u64 = 0xfd569bd55421dde4;
    }
  }
}
